import json
import jydoop
import healthreportutils
import random




sampleRate = 0.001
minBuildId = "20130701000000"




setupjob = healthreportutils.setupjob

"""
want to see if there is a difference in the rate of orphanings since GPS's patch landed in:
Nightly would have been 20130511-something. Aurora 20130514-something.
"""


minimalActiveFhrDaysEntrySet = set(["org.mozilla.crashes.crashes","org.mozilla.appSessions.previous"])


def map(fhrDocId, rawJsonIn, context):

    try:
        payload = json.loads(rawJsonIn)
    except KeyError:
        #context.write(("error","bad_payload"),1)
        #context.write("global_count",1)
        return

    try: #was getting errors finding packets without a version field, so had to wrap this test in a try block
        if not (payload["version"]==2):
            return
    except KeyError:
        #context.write(("error","no_version"),1)
        #context.write("global_count",1)
        return


    try: 
        buildIdAt_thisPingDate = payload["geckoAppInfo"]["appBuildID"].strip()
    except:
        try:
            buildIdAt_thisPingDate = payload["data"]["last"]["org.mozilla.appInfo.appinfo"]["appBuildID"].strip()
        except:
            return
    if buildIdAt_thisPingDate<minBuildId:
        #we only want records generated by new builds.
        return


    try:
        thisPingDate = payload["thisPingDate"]
    except KeyError:
        #context.write(("error","no_thisPingDate"),1)
        #context.write("global_count",1)
        return

    try:
        lastPingDate = payload["lastPingDate"]
    except KeyError:
        #context.write(("error","no_lastPingDate"),1)
        #context.write("global_count",1)
        lastPingDate = None


    try:
      updateChannel = payload["geckoAppInfo"]["updateChannel"].strip()
    except:
        try:
            updateChannel = payload["data"]["last"]["org.mozilla.appInfo.appinfo"]["updateChannel"].strip()
        except:
            updateChannel='no_channel'
    if not (updateChannel in ["nightly","aurora","beta"]):
        #context.write(("error","wrong_channel"),1)
        #context.write("global_count",1)
        return


    try:
        os = payload["geckoAppInfo"]["os"]
    except KeyError:
        try:
            os = payload["data"]["last"]["org.mozilla.appInfo.appinfo"]["os"].strip()
        except KeyError:
            os = "no_os"


    try:
        profileCreation = payload["data"]["last"]["org.mozilla.profile.age"]["profileCreation"]
    except KeyError:
        profileCreation = "no_profileCreation"


    try:
        country =payload["geoCountry"]
    except KeyError:
        country="no_country"

    try:
        memory =payload["data"]["last"]["org.mozilla.sysinfo.sysinfo"]["memoryMB"]
    except KeyError:
        memory="no_memory"


    try:
        dataDays = payload["data"]["days"]
        dataDaysDates = dataDays.keys()
    except KeyError:
        return
        dataDaysDates = None


    try:
        numAppSessionsPreviousOnThisPingDate=len(payload["data"]["days"][thisPingDate]['org.mozilla.appSessions.previous']["main"])
    except TypeError:
        # was getting "TypeError: unicode indices must be integers"
        return
    except KeyError:
        numAppSessionsPreviousOnThisPingDate = 0

    try:
        currentSessionTime=payload["data"]["last"]['org.mozilla.appSessions.current']["totalTime"]
    except KeyError:
        currentSessionTime = 0




    #set up the complete list of observed active days. We will need to go back and remove entries from before the FHR activation date.
    activeDays = [thisPingDate]
    activeDays = activeDays+dataDaysDates if dataDaysDates else activeDays
    activeDays = activeDays+[lastPingDate] if lastPingDate else activeDays



    #find the FHR activation date
    if dataDaysDates:
        #if there are dataDaysDates entries, get the first one on which FHR is active
        fhrActivedataDaysDatesList = [day for day in dataDaysDates if not (set(payload["data"]["days"][day].keys())<=minimalActiveFhrDaysEntrySet)]
        # if there are fhr active days, find the first of them; if there are no entries in dataDaysDates that have these fields, perhaps we are looking at an instance that has just had FHR activated, and has some old crashes? in the latter case get the earliest day in activeDays
        if fhrActivedataDaysDatesList:
            fhrActivationDate=min(fhrActivedataDaysDatesList)
        else:
            fhrActivationDate = min(activeDays)
    else:
        #if there are not any dataDaysDates entries, get the earliest day in activeDays, which will be the min of thisPingDate and lastPingDate (and hopefully lastPingDate should not exist in this case...)
        fhrActivedataDaysDatesList = []
        fhrActivationDate = min(activeDays)

    #find the days active since FHR code became active.
    activeDaysSinceFhr = [date for date in activeDays if date>=fhrActivationDate]



    try:
        firstFhrActiveDayData = str( payload["data"]["days"][min(activeDaysSinceFhr)] )
    except KeyError:
        firstFhrActiveDayData = "no_firstFhrActiveDayData"

    context.write(  (os,
                  updateChannel,
                  country,
                  str(memory),
                  str(profileCreation),
                  fhrActivationDate,
                  firstFhrActiveDayData)

                  ,(fhrDocId,rawJsonIn) )







def reduce(k, vIter, context):

    if random.random()>sampleRate:
        #sampling
        return

    i=0
    recordList=[]
    for fhrDocId,rawJsonIn in vIter:
        if i==0:
            zerothRecord=rawJsonIn
        elif i==1:
            #don't write out any records until there are at least 2 found for the fingerprint
            context.write(1,zerothRecord)
            context.write(1,rawJsonIn)
        elif i>1 and i<25:
            context.write(1,rawJsonIn)
        else:
            #to save memory, we only get the first 25 records for a fingerprint
            return

        i+=1




